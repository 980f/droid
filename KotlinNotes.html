<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
    <html>
      <head>
        <meta content="text/html; charset=utf-8" http-equiv="content-type">
        <title>Kotlin Notes</title>
        <meta content="Andy Heilveil" name="author">
        <meta content="Notes on use of Kotlin" name="description">
        <meta content="Kotlin" name="keywords">
        <meta content="BlueGriffon wysiwyg editor" name="generator">
      </head>
      <body>
        <h1>Kotlin tricks and techniques</h1>
        My experience so far is that Kotlin's 'null pointer' robustness is anything but. I get NPE's on code that isn't visible to my application, so whose fault is
        that? Deep inside automatically generated init{}blocks something unspecified was not init by Kotlin internals. -&gt; apparently this is specific to some gui
        classes, and the kotlin automation isn't quite right on its nullity declarations. <br>
        In fact, it seems to be a debugger problem half the time, it creates a buggered up dex file with a failed partial update then gets bent out of shape.
        <hr> object?.member access makes the member access conditional upon the non-nullity of the object.<br>
        object?:other is the object if not null else the other.<br>
        <hr>
        ChangeListener<br>
        <br>
        Delegates.observable implements a single listener. If we implement the equivalent of sigc signals then we should be able to insert one of those in the single
        listener slot.<br>
        <br>
        <ul>
          <li>import kotlin.properties.Delegates</li>
          <li>class User {</li>
          <ul>
            <li>var name: String by Delegates.observable("&lt;no name&gt;") {</li>
            <ul>
              <li>prop, old, new -&gt;</li>
              <li>println("$old -&gt; $new")</li>
            </ul>
            <li>}</li>
          </ul>
          <li>}</li>
          <li>fun main(args: Array&lt;String&gt;) {</li>
          <ul>
            <li>val user = User()</li>
            <li>user.name = "first"</li>
            <li>user.name = "second"</li>
          </ul>
          <li>}</li>
          <li> <br>
          </li>
        </ul>
        <hr>
        <h4>class member as click listener: </h4>
        <pre>fun makeButton(legend: String, clicker: ()-&gt;Unit): Button {
  val button = add(Button::class.java) //instantiates a member of the given class
  button.text = legend
        
  button.setOnClickListener(object : View.OnClickListener {
     //java under the hood needs an interface so we wrap our functional in one.
    override fun onClick(view: View) {
       clicker()
    }
  })
        
  return button
}</pre>
        <br>
        <hr>        
        <h4>Example of object factory:</h4>
        <pre>fun &lt;T&gt; initializeClassWithArgs(clazz: Class&lt;out T&gt;, vararg args: Pair&lt;Any, Class&lt;*&gt;&gt;): T {
  val (argList, argTypes) = args.unzip()
  try {
    val constructor = clazz.getConstructor(*argTypes.toTypedArray())
    return constructor.newInstance(*argList.toTypedArray())
  } catch (e: NoSuchMethodException) {<br>    throw RuntimeException("Can't initialize class ${clazz.name}, no&lt;init&gt;(${argTypes.joinToString()})", e)
  }
}</pre>
</body></html>